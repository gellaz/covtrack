import 'dart:async';

import 'package:bloc/bloc.dart';
import 'package:equatable/equatable.dart';

import '../../ticker.dart';

part 'timer_event.dart';
part 'timer_state.dart';

/// BLoC to manage the business logic behind a Timer.
class TimerBloc extends Bloc<TimerEvent, TimerState> {
  /// Ticker that will manage the ticks (seconds passed) of the timer.
  final Ticker ticker;

  /// Maximum duration of the timer.
  final int duration;

  /// Subscription to the stream of ticks generated by the [ticker].
  StreamSubscription<int> tickerSubscription;

  TimerBloc(this.ticker, this.duration) : assert(ticker != null);

  /// We want the [TimerBloc] to start off in the [Ready] state
  /// with a preset duration of 1 minute (60 seconds).
  @override
  TimerState get initialState => Ready(duration);

  @override
  void onTransition(Transition<TimerEvent, TimerState> transition) {
    print(transition);
    super.onTransition(transition);
  }

  @override
  Stream<TimerState> mapEventToState(
    TimerEvent event,
  ) async* {
    if (event is Start) {
      yield* _mapStartToState(event);
    } else if (event is Pause) {
      yield* _mapPauseToState(event);
    } else if (event is Resume) {
      yield* _mapResumeToState(event);
    } else if (event is Reset) {
      yield* _mapResetToState(event);
    } else if (event is Tick) {
      yield* _mapTickToState(event);
    }
  }

  /// Cancels the [tickerSubscription] when the [TimerBloc] is closed.
  @override
  Future<void> close() {
    tickerSubscription?.cancel();
    return super.close();
  }

  /// If the [TimerBloc] receives a [Start] event, it pushes a [Running] state with the start duration.
  /// In addition, if there was already an open [tickerSubscription] we need to cancel it to deallocate the memory.
  /// Lastly, we listen to the [ticker.tick] stream and on every tick we add a [Tick] event with the remaining duration.
  Stream<TimerState> _mapStartToState(Start start) async* {
    yield Running(start.duration);
    tickerSubscription?.cancel();
    tickerSubscription =
        ticker.tick(start.duration).listen((duration) => add(Tick(duration)));
  }

  /// If the state of our [TimerBloc] is [Running], then we can pause the [tickerSubscription]
  /// and push a [Paused] state with the current timer duration.
  Stream<TimerState> _mapPauseToState(Pause pause) async* {
    if (state is Running) {
      tickerSubscription?.pause();
      yield Paused(state.duration);
    }
  }

  /// If the [TimerBloc] has a state of [Paused] and it receives a [Resume] event, then it resumes the [tickerSubscription]
  /// and pushes a [Running] state with the current duration.
  Stream<TimerState> _mapResumeToState(Resume resume) async* {
    if (state is Paused) {
      tickerSubscription?.resume();
      yield Running(state.duration);
    }
  }

  /// If the [TimerBloc] receives a [Reset] event, it needs to cancel the current [tickerSubscription] so that it isn’t
  /// notified of any additional ticks and pushes a [Ready] state with the original duration.
  Stream<TimerState> _mapResetToState(Reset reset) async* {
    tickerSubscription?.cancel();
    yield Ready(duration);
  }

  /// Every time a [Tick] event is received, if the tick’s duration is greater than 0,
  /// we need to push an updated [Running] state with the new duration. Otherwise, if the
  /// tick’s duration is 0, our timer has ended and we need to push a [Finished] state.
  Stream<TimerState> _mapTickToState(Tick tick) async* {
    yield tick.duration > 0 ? Running(tick.duration) : Finished();
  }
}
